%This document is generated by \LaTeX
% ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%				cs16btech11038 (at) iith (dot) ac (dot) in      
%				CS2323 HW 1
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
\documentclass[12pt]{article}
 
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb}
 
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
 
\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{exercise}[2][Exercise]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{proposition}[2][Proposition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
 
\begin{document}
 
% --------------------------------------------------------------
%                         Document Content
% --------------------------------------------------------------

\renewcommand{\qedsymbol}{} %I Don't want to display the qed symbol
 
\title{Homework Assignment \#1}
\author{Supreet Singh\\ 
CS2323 - Computer Architecture} 
 
\maketitle
\text{This document is generated by \LaTeX} 
 %~~~~~~~~~~~~~~~~~~~~~~~~
%		Q1 Starts
%~~~~~~~~~~~~~~~~~~~~~~~~
\begin{exercise}[Question]{1} 
(4 marks) A cache has block size of 64B and has 4096 sets and 16 ways, thus
a cache size of 4MB. Consider an address 0xCDDBAA accessed by an
application. Find its set index in the cache. Also find which of the 16 ways it can
be mapped to.
\end{exercise}
 
\begin{proof}[Answer]
Memory address is: \texttt{0xCDDBAA} \\
Its binary representation is: \verb|1100 1101 1101 1011 1010 1010| \\
Block Size: \verb|64B| \\
Byte Offset Size: $\log_2 64$ = 6 \\
The 6 least significant bits represent the byte offset. \\
No. of sets: 4096 and $\log(4096)$ = 12 \\
Set Index is bits 7-18 (7 being the 7th least significant bit). The remaining bits constitute the tag. \\
The set index is: \verb|01 1101 1011 10|, which is 1902 in decimal. \\
Hence, the address maps to \textbf{1903th set} (since set index 0 is the first set) \\
\textbf{If any of the 16 ways in that set is empty, then the address can map to any of the empty ways. Otherwise, it depends on which technique is used to select the way which must be replaced.}

\end{proof} 
 %~~~~~~~~~~~~~~~~~~~~~~~~
%		Q2 Starts
%~~~~~~~~~~~~~~~~~~~~~~~~
\begin{exercise}[Question]{2}
(2 marks) Consider an L2 cache which gets 50000000 accesses per second. It is
designed with a memory which has leakage power of 0.08W and dynamic energy of
0.9nJ/access. If an application executes for one second, how much percentage of
total cache energy comes from leakage energy? 
\end{exercise}
 
\begin{proof}[Answer]
Accesses per second: 50000000 \\
Energy per access: $0.9 \times 10^{-9}$ J \\
Total energy for accesses in 1 second: $0.9 \times 10^{-9} \times 50000000$ = 0.045 J \\
Leakage energy dissipated in 1 second: $0.08 \times 1$ = 0.08 J \\
Total Energy Dissipated: 0.125 J \\
Percentage of energy that is leakage energy: $\frac{100\times 0.08}{0.125}$= \textbf{64\%} \\
\end{proof}
%~~~~~~~~~~~~~~~~~~~~~~~~
%		Q3 Starts
%~~~~~~~~~~~~~~~~~~~~~~~~

\begin{exercise}[Question]{3}
	(14 marks) Assume that a processor uses 8-bit address space. Assume that the
address pattern that accesses the cache is:
Sequence1: 0, 63, 1, 62, 2, 61, 3, 60, 4, 59, 5, 58, 6, 57, 7, 56, 8, 55, 9, 54, 10, 53,
11, 52
Assume two different caches use the following two different address subdivision
methods \ldots (Complete question not written) 
\end{exercise}
 
\begin{proof}[Answer] \textbf{(a)} 	Address space uses 8 bits. \\
	For \textbf{Sequence 1  and Cache 1 }: \\ %CACHE 1 AND SEQUENCE 1 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Block size is 4B. Hence, $\log_2 4$ = 2 least significant bits in the address form the block offset. \\
There are 8 sets, hence $\log_2 8$ = 3 next least significant bits form the set index. \\
The remaining bits are tag. 
\begin{center}
\begin{tabular}{||c | c |  c | c | c | c ||}
\hline
\textbf{S.No.} & \textbf{Address} &  \textbf{Tag} &\textbf{Set Index} & \textbf{Offset} & \textbf{Hit or Miss } \\  \hline
1 & 0 & \verb|000| & \verb|000| & \verb|00| & Miss \\ \hline
2 & 63 & \verb|001| & \verb|111| & \verb|11| & Miss \\ \hline
3 & 1 & \verb|000| & \verb|000| & \verb|01| & Hit \\ \hline 
4 & 62 & \verb|001| & \verb|111| & \verb|10| & Hit \\ \hline
5 & 2 & \verb|000| & \verb|000| & \verb|10| & Hit \\ \hline
6 & 61 & \verb|001| & \verb|111| & \verb|01| & Hit \\ \hline
7 & 3 & \verb|000| & \verb|000| & \verb|11| & Hit \\ \hline
8 & 60 & \verb|001| & \verb|111| & \verb|00| & Hit \\ \hline
9 & 4 & \verb|000| & \verb|001| & \verb|00| & Miss \\ \hline
10 & 59 & \verb|001| & \verb|110| & \verb|11| & Miss\\ \hline
11 & 5 & \verb|000| & \verb|001| & \verb|01| & Hit \\ \hline
12 & 58 & \verb|001| & \verb|110| & \verb|10| & Hit \\ \hline
13 & 6 & \verb|000| & \verb|001| & \verb|10| & Hit \\ \hline
14 & 57 & \verb|001| & \verb|110| & \verb|01| & Hit \\ \hline
15 & 7 & \verb|000| & \verb|001| & \verb|11| & Hit \\ \hline
16 & 56 & \verb|001| & \verb|110| & \verb|00| & Hit \\ \hline
17 & 8 & \verb|000| & \verb|010| & \verb|00| & Miss\\ \hline
18 & 55 & \verb|001| & \verb|101| & \verb|11| & Miss \\ \hline
19 & 9 & \verb|000| & \verb|010| & \verb|01| & Hit \\ \hline
20 & 54 & \verb|001| & \verb|101| & \verb|10| & Hit \\ \hline
21 & 10 & \verb|000| & \verb|010| & \verb|10| & Hit \\ \hline
22 & 53 & \verb|001| & \verb|101| & \verb|01| & Hit \\ \hline
23 & 11 & \verb|000| & \verb|010| & \verb|11| & Hit \\ \hline
24 & 52 & \verb|001| & \verb|101| & \verb|00| & Hit \\ \hline
\end{tabular}
\end{center}
For this cache, hits = 18 and total accesses = 24. (In this case the only misses are compulsory misses). \\
\[ Hit rate = \frac{18}{24} = 0.75 \] 
%SEQUENCE 1 AND CACHE 2 ~~~~~~~~~~~~~~~~~~~~~~
For \textbf{Sequence 1  and Cache 2 }: \\ 
Block size is 4B. Hence, $\log_2 4$ = 2 most significant bits in the address form the block offset. \\
There are 8 sets, hence $\log_2 8$ = 3 next most significant bits form the set index. \\
The remaining bits are tag. 
\begin{center}
\begin{tabular}{||c | c |  c | c | c | c ||}
\hline
\textbf{S.No.} & \textbf{Address} &  \textbf{Tag} &\textbf{Set Index} & \textbf{Offset} & \textbf{Hit or Miss } \\  \hline
1 & 0 & \verb|00| & \verb|000| & \verb|000| & Miss \\ \hline
2 & 63 & \verb|00| & \verb|111| & \verb|111| & Miss \\ \hline
3 & 1 & \verb|00| & \verb|000| & \verb|001| & Miss \\ \hline 
4 & 62 & \verb|00| & \verb|111| & \verb|110| & Miss \\ \hline
5 & 2 & \verb|00| & \verb|000| & \verb|010| & Miss\\ \hline
6 & 61 & \verb|00| & \verb|111| & \verb|101| & Miss \\ \hline
7 & 3 & \verb|00| & \verb|000| & \verb|011| & Miss \\ \hline
8 & 60 & \verb|00| & \verb|111| & \verb|100| & Miss \\ \hline
9 & 4 & \verb|00| & \verb|000| & \verb|100| & Miss \\ \hline
10 & 59 & \verb|00| & \verb|111| & \verb|011| & Miss\\ \hline
11 & 5 & \verb|00| & \verb|000| & \verb|101| & Miss \\ \hline
12 & 58 & \verb|00| & \verb|111| & \verb|010| & Miss \\ \hline
13 & 6 & \verb|00| & \verb|000| & \verb|110| & Miss \\ \hline
14 & 57 & \verb|00| & \verb|111| & \verb|001| & Miss \\ \hline
15 & 7 & \verb|00| & \verb|000| & \verb|111| & Miss\\ \hline
16 & 56 & \verb|00| & \verb|111| & \verb|000| & Miss \\ \hline
17 & 8 & \verb|00| & \verb|001| & \verb|000| & Miss\\ \hline
18 & 55 & \verb|00| & \verb|110| & \verb|111| & Miss \\ \hline
19 & 9 & \verb|00| & \verb|001| & \verb|001| & Miss \\ \hline
20 & 54 & \verb|00| & \verb|110| & \verb|110| & Miss \\ \hline
21 & 10 & \verb|00| & \verb|001| & \verb|010| & Miss \\ \hline
22 & 53 & \verb|00| & \verb|110| & \verb|101| & Miss \\ \hline
23 & 11 & \verb|00| & \verb|001| & \verb|011| & Miss \\ \hline
24 & 52 & \verb|00| & \verb|110| & \verb|100| & Miss \\ \hline
\end{tabular}
\end{center}
For this cache, hits = 0 and total accesses = 24. \\
\[ Hit rate = \frac{0}{24} = 0.00 \] \\
%SEQUENCE 2 AND CACHE 1:
\textbf{(b)} 	Address space uses 8 bits. \\
	For \textbf{Sequence 2  and Cache 1 }: \\ %CACHE 1 AND SEQUENCE 1 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Block size is 4B. Hence, $\log_2 4$ = 2 least significant bits in the address form the block offset. \\
There are 8 sets, hence $\log_2 8$ = 3 next least significant bits form the set index. \\
The remaining bits are tag. 
\begin{center}
\begin{tabular}{||c | c |  c | c | c | c ||}
\hline
\textbf{S.No.} & \textbf{Address} &  \textbf{Tag} &\textbf{Set Index} & \textbf{Offset} & \textbf{Hit or Miss } \\  \hline
1 & 0 & \verb|000| & \verb|000| & \verb|00| & Miss \\ \hline
2 & 64 & \verb|010| & \verb|000| & \verb|00| & Miss \\ \hline
3 & 128 & \verb|100| & \verb|000| & \verb|00| & Miss \\ \hline 
4 & 192 & \verb|110| & \verb|000| & \verb|00| & Miss \\ \hline
5 & 1 & \verb|000| & \verb|000| & \verb|01| & Miss \\ \hline
6 & 65 & \verb|010| & \verb|000| & \verb|01| & Miss \\ \hline
7 & 129 & \verb|100| & \verb|000| & \verb|01| & Miss \\ \hline
8 & 193 & \verb|110| & \verb|000| & \verb|01| & Miss \\ \hline
9 & 11 & \verb|000| & \verb|010| & \verb|11| & Miss \\ \hline
10 & 75 & \verb|010| & \verb|010| & \verb|11| & Miss\\ \hline
11 & 139 & \verb|100| & \verb|010| & \verb|11| & Miss \\ \hline
12 & 203 & \verb|110| & \verb|010| & \verb|11| & Miss \\ \hline
13 & 9 & \verb|000| & \verb|010| & \verb|01| & Miss \\ \hline
14 & 137 & \verb|100| & \verb|010| & \verb|01| & Miss \\ \hline
15 & 201 & \verb|110| & \verb|010| & \verb|01| & Miss \\ \hline
16 & 73 & \verb|010| & \verb|010| & \verb|01| & Miss \\ \hline
\end{tabular}
\end{center}
For this cache, hits = 0 and total accesses = 16. \\
\[ Hit rate = \frac{0}{16} = 0.00 \] 
%SEQUENCE 2 AND CACHE 2 ~~~~~~~~~~~~~~~~~~~~~~
For \textbf{Sequence 2  and Cache 2 }: \\ 
Block size is 4B. Hence, $\log_2 4$ = 2 most significant bits in the address form the block offset. \\
There are 8 sets, hence $\log_2 8$ = 3 next most significant bits form the set index. \\
The remaining bits are tag. 
\begin{center}
\begin{tabular}{||c | c |  c | c | c | c ||}
\hline
\textbf{S.No.} & \textbf{Address} &  \textbf{Tag} &\textbf{Set Index} & \textbf{Offset} & \textbf{Hit or Miss } \\  \hline
1 & 0 & \verb|00| & \verb|000| & \verb|000| & Miss* \\ \hline
2 & 64 & \verb|01| & \verb|000| & \verb|000| & Hit \\ \hline
3 &128 & \verb|10| & \verb|000| & \verb|000| & Hit \\ \hline 
4 & 192 & \verb|11| & \verb|000| & \verb|000| & Hit \\ \hline
5 & 1 & \verb|00| & \verb|000| & \verb|001| & Miss\\ \hline
6 & 65 & \verb|01| & \verb|000| & \verb|001| & Hit \\ \hline
7 & 129 & \verb|10| & \verb|000| & \verb|001| & Hit \\ \hline
8 & 193 & \verb|11| & \verb|000| & \verb|001| & Hit \\ \hline
9 & 11 & \verb|00| & \verb|001| & \verb|011| & Miss* \\ \hline
10 & 75 & \verb|01| & \verb|001| & \verb|011| & Hit \\ \hline
11 & 139 & \verb|10| & \verb|001| & \verb|011| & Hit \\ \hline
12 & 203 & \verb|11| & \verb|001| & \verb|011| & Hit \\ \hline
13 & 9 & \verb|00| & \verb|001| & \verb|001| & Miss \\ \hline
14 & 137 & \verb|10| & \verb|001| & \verb|001| & Hit \\ \hline
15 & 201 & \verb|11| & \verb|001| & \verb|001| & Hit \\  \hline
16 & 73 & \verb|01| & \verb|001| & \verb|001| & Hit \\ \hline
\end{tabular}
\end{center}
For this cache, hits = 12 and total accesses = 16. (The Misses marked with $*$ are compulsory misses, and the rest are conflict misses. \\
\[ Hit rate = \frac{12}{16} = 0.75 \]  
\\
\textbf{(c)} As can be seen from (a) and (b), cache subdivision method 1 is better if the memory addresses we are accessing are contiguous (i.e. one after the other or have spatial locality). An example can be accessing elements of a 2D array row-wise. \\ Cache subdivision method 2 is better suited if the program accesses memory locations  that differ by their higher order bits. An example can be accessing elements of a 2D array column wise (an array for this sequence can be of the type \verb|array[4][64]| | first we access \verb|array[0][0]|, then \verb|array[1][0]|, then \verb|array[2][0]| and so on).
\end{proof}

%~~~~~~~~~~~~~~~~~~~~~~~~
%		Q4 Starts
%~~~~~~~~~~~~~~~~~~~~~~~~
\begin{exercise}[Question]{4}
(4 marks) Consider two processors (P1 and P2) which run the same instruction
set architecture (ISA). The frequency of P1 and P2 are 2GHz and 1.5GHz,
respectively.
In this ISA, there are four classes of instructions A, B, C, and D. The CPI of each of
these classes are given in the following table.
There is a program which has $10^{6}$ instructions divided into classes as follows: 20\%
class A, 25\% class B, 40\% class C, and 15\% class D. Which processor is faster for
this program?\\
\begin{center}
\begin{tabular}{|| c | c | c | c | c ||} \hline
& A & B & C & D \\
P1 & 1 & 2 & 3 & 4 \\
P2 & 2 & 2 & 2 & 2 \\ \hline
\end{tabular}
\end{center}
\end{exercise}
\begin{proof}[Answer] 
	For processor P1: Total number of cycles to be executed: $10^{6} \times (0.2\times1 + 0.25\times2 + 0.4\times3 + 0.15\times4)$ = $2.5 \times 10^{6}$ Cycles. \\
Time taken to execute these: $\frac{2.5 \times 10^{6}}{ 2 \times 10^{9}}$ = $1.25 \times 10^{-3}$ seconds \\

For processer P2: Total number of cycles to be executed: $10^{6} \times (0.2\times 2 + 0.25\times 2 + 0.4 \times 2 + 0.15 \times 2)$ = $2 \times 10^{6} $ Cycles \\
Time taken to execute these: $\frac{2 \times 10^{6}}{1.5 \times 10^{9}} $ = $1.33 \times 10^{-3}$ seconds
\\
\\ Hence, \textbf{Processor P1} is better choice for this program.

\end{proof}

%~~~~~~~~~~~~~
%          Q5 STARTS
%~~~~~~~~~~~~~
 
\begin{exercise}[Question]{5}
(7 marks) Assume that a system has 4 processors (P=4). Assume that directory-
based coherence protocol is used. Show the state of (P+1) bit directory for a cache block after each of these operations to that block.

\renewcommand{\theenumi}{\roman{enumi}}
\begin{enumerate}
\item P0 has read miss
\item P1 has write miss
\item P2 has write miss
\item P3 has read miss
\item P3 has write miss
\item P1 has read miss
\end{enumerate}
\end{exercise}

\begin{proof}[Answer]
The first 4 bits (most significant) represent the processors P0 - P3. The fifth bit is the exclusive bit.
	 \begin{center}
		i.
		\begin{tabular}{|| c c c c c||}
		\hline
		P0 & P1 & P2 & P3 & Ex \\ [0.5ex]
		\hline \hline
		1 & 0 & 0 & 0 & 0 \\ \hline
		\end{tabular}
	\end{center}
	\begin{center}
		ii.
		\begin{tabular}{|| c c c c c||}
		\hline
		P0 & P1 & P2 & P3 & Ex \\ [0.5ex]
		\hline \hline
		0 & 1 & 0 & 0 & 1 \\ \hline
		\end{tabular}
	\\ Since P1 has now writing to the cache block, P0's copy is now invalid and P1 has exclusive access to the cache block.
	\end{center}
	\begin{center}
		iii.
		\begin{tabular}{|| c c c c c||}
		\hline
		P0 & P1 & P2 & P3 & Ex \\ [0.5ex]
		\hline \hline
		0 & 0 & 1 & 0 & 1 \\ \hline
		\end{tabular}
	\\ Similarly, now P2 writes to the cache block and it has exclusive access now, making P1's copy invalid. Exclusive bit stays 1.
	\end{center}
	\begin{center}
		iv.
		\begin{tabular}{|| c c c c c||}
		\hline
		P0 & P1 & P2 & P3 & Ex \\ [0.5ex]
		\hline \hline
		0 & 0 & 1 & 1 & 0 \\ \hline
		\end{tabular}
	\\ P3 now re fetches the cache block and P2 no longer has exclusive access to the cache block. Hence exclusive bit is 0. However, P2's copy still is valid hence P2 bit remains 1.
	\end{center}
	\begin{center}
		v.
		\begin{tabular}{|| c c c c c||}
		\hline
		P0 & P1 & P2 & P3 & Ex \\ [0.5ex]
		\hline \hline
		0 & 0 & 0 & 1 & 1 \\ \hline
		\end{tabular}
	\\ P3 has a write miss, making P2's copy invalid and the exclusive bit turns 1.
	\end{center}
	\begin{center}
		vi.
		\begin{tabular}{|| c c c c c||}
		\hline
		P0 & P1 & P2 & P3 & Ex \\ [0.5ex]
		\hline \hline
		0 & 1 & 0 & 1 & 0 \\ \hline
		\end{tabular}
\\ P1 gets the latest copy of the cache block and P3 no longer has exclusive access. Hence exclusive bit turns 0.
	\end{center}

\end{proof}

\begin{exercise}[Question]{6}
(4 marks) Two applications are running on a processor which has shared L2
cache.
For application1: L2 cache misses with 2 and 6 ways (of last level cache) are 1000
and 500, respectively.

For application2: L2 cache misses with 2 and 6 ways (of last level cache) are 2000
and 1800, respectively
Assume that in between 2 and 6 ways, number of misses scale linearly (i.e., use
linear interpolation).
Assume the cache has 8 ways, then which application should get how many ways
for improving performance.
\end{exercise}

\begin{proof}[Answer]
	For app 1: 2 ways correspond to  1000 misses, 6 ways correspond to 500 misses. \\ Hence the $misses$ as a function of number of ways ($x$), can be written as: \[ miss(x) = -125x +1250 \] %Eqn...
Similarly, for app 2: 2 ways correspond to 2000 misses and 6 ways correspond to 1800 misses. \\ Hence the $misses$ as a function of number of ways ($y$), can be written as: \[ miss(y): -50y + 2100 \] %Eqn...
We have the following constraints: \[ x+y=8 \] \[2 <= x, y <= 6  \]
We have to minimize $miss(x) + miss(y)$. \\
That is, minimize: $-125x -50y + 3350$ subject to the above contraints. This will be minimized when x = 6 and y =2. \\ \textbf{Hence 6 ways should be given to App 1 and 2 ways should be given to App 2.}

\end{proof}
% --------------------------------------------------------------
%     End is here
% --------------------------------------------------------------
 
\end{document}